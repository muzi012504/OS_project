# LAB3
## 练习1

### 实现过程分析

1. **初始化阶段**

在`idt_init()`中，通过`write_csr(stvec, &__alltraps)`设置异常与中断入口地址，使CPU能在中断或异常发生时跳转到统一入口`__alltraps`进行处理。在定时器初始化阶段，`clock_set_next_event()`设置下一次时钟中断的触发时间，保证中断周期性发生。

2. **中断触发与分发**

当时钟中断触发后，CPU自动保存当前上下文信息，并进入汇编入口`__alltraps`，再跳转到C语言的`trap()`函数。`trap()`调用`trap_dispatch()`，根据`tf->cause`判断类型并分发至`interrupt_handler()`处理。

3. **时钟中断处理逻辑**

在`interrupt_handler()`中的`IRQ_S_TIMER`分支内：

- 调用`clock_set_next_event()`重新设置下次中断；

- 使用`ticks`记录中断次数，每累计100次调用`print_ticks()`输出 “100 ticks”；

- 使用`print_num`记录打印次数，达到10次后调用`sbi_shutdown()`关机。

### 定时器中断处理流程

1. **时钟中断触发**  
   当定时器达到设定的时间点时，硬件自动向CPU发出时钟中断信号。

2. **陷入中断处理程序**  
   CPU接收到中断信号后，自动保存当前的程序计数器（`sepc`）和状态寄存器（`sstatus`）等关键信息，然后跳转到内核在`stvec`中设置的中断入口地址，即`__alltraps`。

3. **保存现场**  
   在`__alltraps`汇编入口中，内核依次保存所有通用寄存器到中断帧（`trapframe`）中，以防止中断处理破坏原有程序的执行环境。

4. **进入 C 语言处理函数**  
   汇编入口调用 C 语言的`trap()`函数，进行具体的中断类型判断与分发。

5. **中断类型分发**  
   在`trap()`中，通过读取`scause`的值判断中断或异常类型，并调用`trap_dispatch()`进行相应的分支处理。当检测到是时钟中断（`IRQ_S_TIMER`）时，进入`interrupt_handler()`中的时钟中断分支。

6. **处理中断**  
   在时钟中断分支中：
    - 调用`clock_set_next_event()`设置下一次时钟中断的触发时间；
    - 增加全局计数变量`ticks`；
    - 当`ticks`达到 100 的倍数时，调用`print_ticks()`输出 “100 ticks”；
    - 记录打印次数，当打印 10 次后调用`sbi_shutdown()`关机。

7. **恢复现场**  
   时钟中断处理完成后，`trap()`函数返回，内核在`__trapret`汇编中恢复所有寄存器及`sepc`、`sstatus`，恢复到中断前的状态。

8. **返回原程序**  
   最后，执行`sret`指令，从内核态返回到中断发生前的用户程序或内核主循环中，继续执行原先的代码。



## challenge1: 
1. **ucore中中断异常的完整处理流程**

- 异常产生：U模式程序触发异常（如执行ecall、缺页）或中断（如时钟中断），硬件自动执行：保存被中断指令地址到sepc、记录异常原因到scause、保存附加信息到stval，并将特权级切换至S模式，同时禁用S模式中断（sstatus.SIE清零，SPIE保存原SIE值）。

- 跳转至中断入口：硬件根据stvec寄存器的值，跳转到__alltraps（中断入口点）。

- 保存上下文：执行SAVE_ALL汇编宏，在栈上开辟空间（36个uintptr_t大小），依次保存32个通用寄存器和sscratch、sstatus、sepc、sbadaddr、scause共5个关键寄存器，形成struct trapframe结构体。

- 调用中断处理函数：通过move a0, sp将栈顶（即struct trapframe的地址）作为参数传入C语言函数trap。

- 分发处理逻辑：trap函数调用trap_dispatch，根据scause判断是中断还是异常，分别调用interrupt_handler或exception_handler，执行具体处理（如时钟中断计数、非法指令提示）。

- 恢复与返回：处理完成后回到__trapret，执行RESTORE_ALL宏恢复所有寄存器，最后通过sret指令恢复sepc到pc、恢复SIE状态，从S模式返回U模式，继续执行原程序。

2. **mov a0, sp的目的**

根据RISC-V调用约定，a0寄存器用于传递函数的第一个参数。这条指令的目的是将栈顶指针（指向保存好的struct trapframe结构体首地址）作为参数，传递给后续调用的C语言中断处理函数trap，使trap能访问中断现场的寄存器数据和异常信息。

3. **SAVE_ALL中寄存器在栈中的保存位置**

由**struct trapframe结构体的成员顺序和汇编宏中显式指定的偏移量**共同确定：

（1）struct trapframe定义了通用寄存器（gpr，含x0-x31）和4个CSR寄存器（status、epc、badvaddr、cause）的排列顺序，对应栈上从低地址到高地址的存储顺序。

（2）汇编宏中通过STORE 寄存器, N*REGBYTES(sp)指定位置，例如STORE x0, 0*REGBYTES(sp)对应gpr.zero，STORE s1, 32*REGBYTES(sp)对应status（因前32个偏移量用于通用寄存器）。

4. **__alltraps中是否需要保存所有寄存器**

必须保存所有寄存器：

中断处理会临时占用通用寄存器，而被中断的用户程序或内核代码在恢复后需要完全回到中断前的执行状态（包括所有寄存器的值）。若未保存全部寄存器（如仅保存部分临时寄存器），会导致恢复后程序因寄存器值被篡改而执行错误（例如函数返回地址ra、栈指针sp等关键寄存器丢失会直接导致程序崩溃）。




## challenge 2
### 汇编指令分析
- `csrw sscratch, sp`

把当前栈指针`sp`写入CSR寄存器`sscratch`中。由于在执行trap时，硬件不会自动保存旧的寄存器的内容，使用`sscratch`来临时保存trap前的栈指针，避免丢失用户态栈。

- `csrrw s0, sscratch, x0`

这个指令实现了将`sscratch`中的值放到`s0`中，同时把`x0`写回`sscratch`,即把`sscratch`清零并把旧值读到`s0`。清空`sscratch`，可以防止异常嵌套混淆来源。

### RESTORE_ALL不还原

在`SAVE_ALL`时保存了`sstatus`、`sepc`、`sbadaddr`、`scause`。`sstatus`保存了当前CPU在进入中断前的状态信息，`sepc`保存了触发异常的指令地址。这两项需要保存并恢复才能保证处理完中断后能准确的恢复现场。

但是对`sbadaddr`、`scause`只保存不恢复是由于这两个寄存器主要保存了异常的原因和相关的地址信息。在`SAVE_ALL`时保存是因为这方便通过读取`sbadaddr`、`scause`来做dispatch、打印和修改`epc`等操作，方便进行调试；在`RESTORE_ALL`时，`sret`的行为不依赖`sbadaddr`、`scause`中的信息，恢复没有意义。

## 实验与OS原理对应的重要知识点
1. **中断/异常机制**

实验知识点：RISC-V的Trap分类（异步中断如时钟中断、同步异常如缺页）、中断路由（M模式委托至S模式）、硬件寄存器（sepc/scause/stval）自动保存、软件上下文切换（SAVE_ALL/RESTORE_ALL宏、trapframe结构体）。

OS原理知识点：中断机制定义（打破CPU执行顺序响应事件）、中断处理流程（请求→响应→保现场→处理→恢复→返回）、特权级隔离（用户态/内核态切换）。

理解：二者目标一致（高效响应+系统安全），实验是原理的架构级落地（如用汇编宏实现“保现场”）；原理讲通用逻辑（“为什么保现场”），实验讲具体操作（“RISC-V如何保现场”）。

2. **特权级与模式切换**
实验知识点：RISC-V三级特权级（M/S/U）、U态通过ecall陷S态、S态通过sret返U态、OpenSBI的M态支持。

OS原理知识点：用户态/内核态划分、模式切换必要性（防用户破坏系统）、系统调用（用户请求内核服务的入口）。

理解：实验是原理的硬件实现（如ecall对应系统调用）；原理抽象两级特权，实验中M态是RISC-V特有的底层特权级，原理不涉及。

3. **中断使能与屏蔽**
实验知识点：sstatus.SIE/SPIE位控制、sie寄存器屏蔽特定中断、local_intr_save/restore宏保证原子操作。

OS原理知识点：中断屏蔽作用（保证关键操作原子性）、中断优先级（高优先级打断低优先级）。

理解：二者逻辑一致（屏蔽中断防操作被打断）；实验用寄存器操作落地原理，原理中“中断优先级调度”在实验中未体现（仅允许/禁止某类中断）。


## OS原理重要但实验未对应的知识点
1. 进程管理与调度算法：原理中进程PCB、状态转换、RR调度等核心内容，实验仅模拟时钟中断计数，无多进程创建与切换。
2. 虚拟内存完整逻辑：原理中多级页表、地址翻译、LRU页面置换，实验仅涉及物理内存管理，无虚拟内存落地。
3. 文件系统：原理中文件结构、目录管理、I/O重定向，实验仅提磁盘I/O中断概念，无文件系统实现。
4. 进程同步与互斥：原理中信号量、管程、临界区问题，实验仅用中断屏蔽保证原子性，无多进程同步逻辑。
5. 死锁处理：原理中死锁必要条件、银行家算法等，实验无多进程资源竞争场景，不涉及死锁相关设计。