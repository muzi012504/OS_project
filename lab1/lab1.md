# 操作系统实验一报告

## 练习1：理解内核启动中的程序入口操作

### 指令 `la sp, bootstacktop`

**操作**：这是一条伪指令，其核心操作是将 `bootstacktop` 所代表的地址值加载到栈指针寄存器 `sp` 中。

- `bootstacktop` 是在同一文件 `.data` 段中定义的标签，它指向预先分配好的一块大小为 `KSTACKSIZE` 的内存区域的最高地址
- 执行此指令后，栈指针 `sp` 便指向了内核栈的栈顶

**目的**：根本目的是为 C 代码的执行初始化一个可用的栈空间

- 满足 C 语言函数调用的基本要求：C 语言的函数调用、局部变量存储、寄存器保存等都严重依赖于栈。在调用任何 C 函数之前，必须设置好栈指针，否则程序会立即崩溃
- 确立栈的生长方向：在 RISC-V 架构中，栈通常从高地址向低地址生长。将 `sp` 初始化为 `bootstacktop`，`bootstacktop` 指向栈顶，符合这一约定，后续的 `push` 操作将通过递减 `sp` 来实现
- 提供中断/异常的处理基础：当发生中断或异常时，硬件需要将当前上下文保存到内存中，而栈是完成这一任务的标准场所。一个有效的栈是中断机制能够工作的前提

### 指令 `tail kern_init`

**操作**：这是一条尾调用指令，其核心操作是无条件地跳转到 `kern_init` 函数的入口地址，并且不将返回地址保存到链接寄存器 `ra` 中

**目的**：根本目的是通过尾调用方式，将处理器的执行控制权从汇编启动代码正式移交至内核的主 C 语言初始化例程，完成内核启动阶段的最终切换

- 完成从汇编到 C 语言的最终切换：这是启动流程中的一个重要里程碑。至此，CPU 的执行权正式从底层的、负责最基础硬件设置的汇编代码，移交给了用高级 C 语言编写的、负责内核主要初始化逻辑的 `kern_init` 函数
- 优化栈帧的使用：由于 `kern_init` 函数被声明为 `__attribute__((noreturn))`，意味着它永远不会返回到它的调用者（即 `kern_entry`）。因此，为 `kern_entry` 保留栈帧和返回地址是完全没有必要的。`tail` 指令避免了在栈上创建新的帧，实现了栈帧的"复用"，使得 `kern_init` 可以直接使用当前 `kern_entry` 的栈帧，节省了内存并简化了控制流
- 表明启动过程的不可逆性：这条指令清晰地传达了一个语义：内核的启动过程是单向的。汇编引导代码的使命已经完成，CPU 进入 C 语言内核的世界，不会再回到这个启动入口

## 练习2：使用 GDB 验证启动流程

### 调试过程

1. **CPU从复位地址0x1000开始执行OpenSBI初始化代码**

在一个终端中输入
make debug
编译代码并启动QEMU模拟器，启动模拟的RISC-V，加载OpenSBI固件，把内核镜像加载到0x80200000,并暂停在加电复位处。
在另一个终端输入
make gdb
进入GDB调式环境

   ```bash
   # 终端1
   make debug
   
   # 终端2  
   make gdb
   ```
然后通过在终端输入：
   ```gdb
   (gdb) info registers
   ```
可以在输出看到当前pc为0x1000，即当前CP在复位地址0x1000，正在准备执行OpenSBI的第一条指令。

2. **SBI固件主初始化并加载内核到0x80200000**

这里要观察内核写入内存的瞬间，但是在实际操作是watchpoint监控大块内存是qemu执行十分慢，使用在内核入口设置断点后确认内核镜像已加载。
   ```gdb
   (gdb) b *0x80200000
   (gdb) c
   (gdb) x/16x 0x80200000
   ```
可以观察到输出：
   ```gdb
   0x80200000 <kern_entry>:        0x00003117      0x00010113      0x3517a009      0x05130000
   0x80200010 <kern_init+6>:       0x3617ffe5      0x06130000      0x1141ff66      0x8e094581
   0x80200020 <kern_init+22>:      0x00efe406      0x059708c0      0x85930000      0x05174a25
   0x80200030 <kern_init+38>:      0x05130000      0x00ef4ba5      0xa0010200      0xe0221141
   ```
当断点触发时，说明内核镜像已成功加载到内存0x80200000。且使用x/16x可以看到内核前几个指令已经写入内存。
3. **SBI跳转0x80200000**

可以从上面设置断点后的输出：
   ```gdb
   Breakpoint 1, kern_entry () at kern/init/entry.S:7
   7           la sp, bootstacktop

   ```
CPU已从SBI跳转到内核入口，内核开始执行第一条指令la sp, bootstacktop，初始化内核栈指针。
### 问题答案

1. **RISC-V 硬件加电后最初执行的几条指令位于什么地址？**

   位于物理地址 `0x1000`到`0x1010`

2. **它们主要完成了哪些功能？**

   主要完成硬件初始化前的准备工作，包括PC基地址获取、偏移计算、Hart ID读取以及跳转到主初始化代码的地址。

## 重要知识点对应关系

### 实验中的重要知识点及其与 OS 原理的对应

| 实验知识点 | OS 原理知识点 | 含义与关系理解 |
|-----------|--------------|---------------|
| 内核启动流程 | 操作系统启动过程 | 实验中从固件代码到内核初始化的流程对应 OS 原理中的启动阶段划分，但具体实现因架构而异 |
| 栈的初始化 | 运行时环境建立 | 内核栈的建立是函数调用和中断处理的基础，体现了栈在程序执行中的核心作用 |
| 控制权转移 | 系统初始化阶段转换 | 从汇编到 C 语言的切换标志着系统从底层初始化进入高级功能初始化阶段 |
| 尾调用优化 | 函数调用机制 | 尾调用避免了不必要的栈帧分配，体现了编译优化与系统性能的关系 |

## OS 原理中重要但实验中没有对应上的知识点

 进程管理和调度

原理概念

进程是操作系统进行资源分配和调度的基本单位，进程管理包括进程的创建、终止、调度、同步和通信等。进程调度算法决定了哪个进程获得CPU时间，常见的有先来先服务、短作业优先、时间片轮转、多级反馈队列等。

实验缺失分析

在本实验中，我们仅完成了内核的启动和基础初始化，尚未涉及：

   进程控制块(PCB)：没有实现描述进程状态的数据结构

   上下文切换：没有保存和恢复进程执行现场（寄存器、程序计数器等）的机制

   调度器：没有实现任何进程调度算法

   进程状态转换：没有就绪、运行、阻塞等状态的管理



进程管理是操作系统的核心功能，它实现了多道程序并发执行，提高了系统资源利用率。没有进程管理，操作系统只能运行单个程序，无法实现现代操作系统的多任务特性。

