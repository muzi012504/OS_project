# ucore OS Lab5 实验报告

## 练习1: 加载应用程序并执行

### 设计实现过程

在`kern/process/proc.c`文件中，`load_icode`函数负责加载并解析ELF格式的应用程序。设置正确的`trapframe`内容，确保进程能从应用程序的起始地址开始执行。

#### 关键实现代码

```c
// 设置用户栈指针为用户栈顶部
tf->gpr.sp = USTACKTOP;
// 设置程序入口点为ELF文件的入口地址
tf->epc = elf->e_entry;
// 设置状态寄存器：清除SPP位（用户模式），设置SPIE位（允许中断），清除SIE位（返回前禁用中断）
tf->status = (sstatus & ~SSTATUS_SPP) | SSTATUS_SPIE;
tf->status &= ~SSTATUS_SIE;
```

#### 实现原理

1. **用户栈指针设置**：将`trapframe`中的栈指针`sp`设置为`USTACKTOP`，这是用户栈的顶部地址，确保用户程序能从正确的栈位置开始执行。

2. **程序入口点设置**：从ELF文件头中获取程序入口地址`elf->e_entry`，并将其设置到`trapframe`的`epc`字段。`epc`寄存器会在从内核态返回到用户态时被加载到`sepc`寄存器，作为程序执行的起始地址。

3. **状态寄存器设置**：
   - 清除`SPP`（Supervisor Previous Privilege）位，确保返回用户模式
   - 设置`SPIE`（Supervisor Previous Interrupt Enable）位，允许中断在返回用户态后继续
   - 清除`SIE`（Supervisor Interrupt Enable）位，确保在返回到用户态之前不会响应中断

### 从RUNNING态到执行第一条指令的过程

1. **调度器选择进程**：调度器从就绪队列中选择一个处于RUNNABLE状态的进程，将其状态改为RUNNING。

2. **切换页表**：调用`proc_run`函数，通过`lsatp`指令将CPU的`satp`寄存器设置为进程的页目录基地址，切换到用户进程的地址空间。

3. **上下文切换**：调用`switch_to`函数，保存当前进程的上下文，恢复新进程的上下文。

4. **执行forkret**：新进程从`forkret`函数开始执行，该函数调用`forkrets`。

5. **恢复trapframe**：`forkrets`函数从进程的`trapframe`中恢复所有寄存器，包括：
   - 通用寄存器（包括`sp`）
   - 程序计数器`sepc`（从`tf->epc`加载）
   - 状态寄存器`sstatus`（从`tf->status`加载）

6. **返回到用户态**：执行`sret`指令，从内核态返回到用户态，开始执行用户程序的第一条指令（`elf->e_entry`指向的地址）。

## 练习2: 父进程复制自己的内存空间给子进程

### 设计实现过程

在`kern/mm/pmm.c`文件中，`copy_range`函数负责将父进程的内存空间复制到子进程。

#### 关键实现代码

**基础内存复制实现**
```c
// 找到源页的内核虚拟地址
void *src_kvaddr = page2kva(page);
// 找到目标页的内核虚拟地址
void *dst_kvaddr = page2kva(npage);
// 从源页复制内容到目标页，大小为一个页面
memcpy(dst_kvaddr, src_kvaddr, PGSIZE);
// 建立目标页物理地址与线性地址start的映射
ret = page_insert(to, npage, start, perm);
```

#### 实现原理

1. **源页与目标页转换**：通过`page2kva`宏将父进程的物理页（`page`）和子进程的新物理页（`npage`）转换为内核虚拟地址，以便在内核态中直接访问和复制页面内容。

2. **页面内容复制**：使用`memcpy`函数将父进程页面的全部内容（4KB）复制到子进程的新页面中，确保子进程拥有与父进程完全相同的内存数据。

3. **建立地址映射**：调用`page_insert`函数，在子进程的页表（`to`）中建立线性地址（`start`）到新物理页（`npage`）的映射，并设置与父进程相同的页面权限（`perm`）。

### Copy on Write（写时复制）机制设计实现

#### 设计思路

写时复制机制的核心思想是：在fork创建子进程时，不立即复制父进程的内存页，而是让父子进程共享同一物理页，并将该页标记为只读。当任何一方尝试写入该页时，触发缺页异常，此时内核才会为写操作的进程分配新的物理页并复制原页内容，然后修改页表映射。

#### 实现方案

1. **页面共享与只读标记**
   - 在`copy_range`函数中，不立即分配新物理页，而是将父进程的物理页直接映射到子进程的地址空间
   - 同时将父子进程的页表项权限设置为只读（清除可写位）

2. **缺页异常处理**
   - 在缺页异常处理函数中，检测是否为写操作访问只读共享页
   - 若为COW页，则分配新物理页，复制原页内容，更新页表映射为可写

3. **页面引用计数**
   - 在`struct Page`中添加`_ref`字段，记录页面被多少进程共享
   - fork时增加引用计数，释放页时减少引用计数
   - 引用计数为0时，真正释放物理页

#### 实现优势

1. **提高fork效率**：fork时无需复制大量内存页，只需修改页表和引用计数，减少了fork的执行时间
2. **节省内存资源**：若父子进程不修改共享页，则共享物理内存，提高了内存利用率
3. **按需分配**：仅在需要写入时才分配新页，实现了内存的按需分配

#### 与原实现的对比

| 特性 | 原实现 | COW实现 |
|------|--------|---------|
| fork时间开销 | 大（需复制所有内存页） | 小（仅修改页表） |
| 内存利用率 | 低（父子进程内存完全独立） | 高（共享未修改的页面） |
| 适用场景 | 所有场景 | 特别适合fork后立即exec的场景 |
| 实现复杂度 | 低 | 中（需处理缺页异常和引用计数） |

## 练习3：阅读分析源代码，理解进程执行 fork/exec/wait/exit 的实现，以及系统调用的实现

### fork/exec/wait/exit 执行流程分析

#### fork
##### 用户态操作
1. 用户程序调用 fork() 函数（封装在 user/libs/ulib.c）。
2. fork() 触发用户态系统调用封装函数 syscall(SYS_fork)，通过内联汇编设置系统调用号 a7=SYS_fork，执行 ecall 指令，触发特权级切换。
##### 内核态操作
1. ecall 触发异常，进入内核异常处理入口 __alltraps，保存用户态上下文到内核栈。
2. 内核根据系统调用号分发到 sys_fork 函数，调用 do_fork 核心逻辑
3. do_fork 完成：复制父进程 proc_struct、复制内存空间（copy_mm）、复制页表、设置子进程状态为 PROC_RUNNABLE，加入就绪队列。
4. 内核恢复上下文，通过 sret 指令返回用户态；父进程返回子进程 PID，子进程返回 0。
##### 交错执行与结果返回
交错：用户态 ecall → 内核态创建子进程 → sret 回到用户态，父子进程分别继续执行。
结果返回：内核在处理完成后，将返回值写入 a0 寄存器；sret 回到用户态后，用户态 syscall 函数读取 a0 寄存器值，作为 fork() 的返回值。

#### exec
##### 用户态操作
1. 用户程序调用 exec() 系列函数（实验中通过 kernel_execve 触发），封装为系统调用 syscall(SYS_exec)。
2. 设置系统调用号、传递程序名/二进制数据等参数，执行 ecall 进入内核。
##### 内核态操作
1. 异常处理后分发到 sys_exec，调用 do_execve 核心逻辑。
2. do_execve 完成：回收当前进程旧的用户内存空间（exit_mmap）、调用 load_icode 加载新程序的 ELF 镜像到用户空间、设置新的程序入口地址。
3. 恢复上下文，sret 返回用户态，新程序从入口地址开始执行。
##### 交错执行与结果返回
交错：用户态发起调用 → 内核态替换进程镜像 → 返回用户态执行新程序。
结果返回：若加载成功，无返回值（新程序直接执行）；若失败，内核设置错误码到 a0，返回用户态后提示执行失败。

#### exit
##### 用户态操作
1. 用户程序调用 exit(int error_code) 函数（user/libs/ulib.c）。
2. 触发系统调用 syscall(SYS_exit, error_code)，执行 ecall 进入内核。
##### 内核态操作
1. 异常处理后分发到 sys_exit，调用 do_exit 核心逻辑。
2. do_exit 完成：回收用户内存空间（exit_mmap）、设置进程状态为 PROC_ZOMBIE、保存退出码、唤醒父进程、将子进程托管给 initproc、调用 schedule() 切换到其他进程。
3. 僵尸进程的资源（内核栈、proc_struct）需等待父进程 wait 时回收。
##### 交错执行与结果返回
交错：用户态发起退出 → 内核态回收大部分资源并切换进程 → 进程不再返回用户态。
结果返回：无返回值给当前进程，退出码保存在 proc_struct 中，供父进程 wait 读取。

#### wait
##### 用户态操作
1. 用户程序调用 wait()/waitpid() 函数（user/libs/ulib.c）。
2. 触发系统调用 syscall(SYS_wait, pid, &store)，执行 ecall 进入内核。
##### 内核态操作
1. 异常处理后分发到 sys_wait，调用 do_wait 核心逻辑。
2. do_wait 完成：遍历子进程，若存在僵尸子进程，则读取其退出码、回收僵尸进程的内核栈和 proc_struct；若无子进程或子进程未退出，则设置父进程状态为 PROC_WAITING，调用 schedule() 切换进程。
3. 子进程退出后唤醒父进程，父进程恢复执行，通过 sret 返回用户态。
##### 交错执行与结果返回
交错：用户态发起等待 → 内核态检查子进程状态，若需等待则切换进程 → 子进程退出后唤醒父进程 → 返回用户态。
结果返回：内核将子进程 PID 和退出码写入 a0 和用户态传入的 store 指针指向的地址，用户态函数读取后返回。

### ucore用户态进程执行状态生命周期图
┌─────────────────┐     进程创建（kernel_execve/load_icode）     ┌─────────────────┐
│                 │ ──────────────────────────────────────────> │ PROC_RUNNABLE   │
│     [初始态]    │                                             │ （就绪态）      │
└─────────────────┘                                             └─────────┬───────┘
                                                                           │
                                                                           │ 调度器选中（schedule()）
                                                                           ▼
┌─────────────────┐     父进程wait回收资源（do_wait()）          ┌─────────────────┐
│  资源释放，进程  │ <───────────────────────────────────────── │ PROC_ZOMBIE     │
│      消亡       │                                             │ （僵尸态）      │
└─────────────────┘                                             └─────────┬───────┘
                                                                           │
                                                                           │ 进程调用exit()（sys_exit/do_exit）
                                                                           ▼
┌─────────────────┐     被唤醒/等待超时（wakeup_proc()）         ┌─────────────────┐
│ PROC_RUNNABLE   │ <───────────────────────────────────────── │ PROC_WAITING    │
│ （就绪态）      │                                             │ （等待态）      │
└─────────┬───────┘                                             └─────────┬───────┘
          │                                                             │
          │ 调度器选中（schedule()）                                    │
          ▼                                                             │
┌─────────────────────────────────────────────────────────────────┐      │
│ PROC_RUNNING（运行态）                                          │      │
├─────────────────────────────────────────────────────────────────┤      │
│ 触发事件/函数                状态转换结果                         │      │
│ ────────────────             ────────────────                    │      │
│ 1. 调用fork()（sys_fork/do_fork）                                │      │
│    → 子进程进入PROC_RUNNABLE，父进程保持PROC_RUNNING             │      │
│                                                                 │      │
│ 2. 调用exec()（sys_exec/do_execve）                              │      │
│    → 替换程序镜像，仍保持PROC_RUNNING                            │      │
│                                                                 │      │
│ 3. 调用wait()（sys_wait/do_wait）且无僵尸子进程                  │      │
│    → 进入PROC_WAITING                                           │ ─────> │
│                                                                 │
│ 4. 调用yield()（sys_yield/do_yield）                            │
│    → 主动放弃CPU，回到PROC_RUNNABLE                             │
│                                                                 │
│ 5. 时间片耗尽/中断（timer_interrupt）                            │
│    → 回到PROC_RUNNABLE                                          │
│                                                                 │
│ 6. 调用exit()（sys_exit/do_exit）                                │
│    → 进入PROC_ZOMBIE                                            │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘
#### 状态变换说明
1. PROC_RUNNABLE（就绪态）：进程已创建/被唤醒，等待调度器选中；由 do_fork/wakeup_proc 触发进入此态。
2. PROC_RUNNING（运行态）：调度器选中进程，占用 CPU 执行；由 schedule 函数触发状态切换。
3. PROC_WAITING（等待态）：进程调用 wait 且无子进程退出，或等待其他事件；由 do_wait 触发，被唤醒后回到就绪态。
4. PROC_ZOMBIE（僵尸态）：进程调用 exit，用户资源已回收，等待父进程回收内核资源；由 do_exit 触发，父进程 wait 后资源释放，进程消亡。

### make grade 验证
#### 执行 make grade 后，若所有应用程序检测项输出 ok，说明 fork/exec/wait/exit 的实现逻辑正确，用户进程的创建、切换、退出和资源回收流程无问题。

## 实验总结

通过本次实验，我深入理解了：

1. **用户程序加载机制**：ELF文件格式解析、内存映射建立和进程执行环境设置
2. **进程切换过程**：从内核态到用户态的转换机制，以及trapframe的作用
3. **内存复制技术**：父进程到子进程的内存空间完整复制实现
4. **进程控制原语**：fork/exec/wait/exit系统调用的完整实现流程
5. **系统调用机制**：从用户态到内核态的转换和系统调用的处理流程
6. **进程状态管理**：进程生命周期中的各种状态转换和管理机制

这些知识对于理解操作系统如何管理进程和内存资源至关重要，为后续学习更复杂的操作系统概念奠定了坚实基础。实验中实现的内存管理和进程加载功能是操作系统的核心组成部分，直接影响系统的性能和资源利用效率。

## 实验重要知识点与对应OS原理知识点的理解
| 实验知识点 | 对应OS原理知识点 | 含义、关系与差异 |
|------------|------------------|------------------|
| 用户态与内核态的特权级切换（ecall/sret） | 特权级划分与模式切换 | 含义：RISC-V的U态（用户态）权限受限，无法执行特权指令；S态（内核态）拥有完整硬件访问权限。ecall触发异常从U态切到S态，sret完成中断处理后从S态切回U态。<br>关系：实验是原理的硬件级实现，ecall/sret是特权级切换的具体指令载体。<br>差异：原理侧重“为什么要划分（隔离保护、资源管控）”，实验侧重“怎么切换（指令触发、中断上下文保存）”。 |
| 系统调用框架（syscall.c、trap处理） | 系统调用机制 | 含义：用户程序通过标准化接口请求内核服务，核心流程是用户态封装调用→ecall触发异常→内核态中断处理→执行系统调用函数→sret返回。<br>关系：实验完整复现了原理的核心流程，包括系统调用号定义、参数传递、中断门注册。<br>差异：原理是通用模型（如Unix的syscall流程），实验针对ucore的精简实现，用ebreak模拟内核态发起exec调用的特殊场景。 |
| 进程管理系统调用（sys_fork/sys_exec/sys_exit/sys_wait） | 进程控制原语 | 含义：<br>- fork：复制父进程地址空间生成子进程，父子进程从fork返回处继续执行；<br>- exec：替换当前进程的内存空间和执行代码，保持PID不变；<br>- exit：进程主动终止，释放大部分资源并进入僵尸态；<br>- wait：父进程等待子进程退出，回收僵尸进程的剩余资源（内核栈、PCB）。<br>关系：实验是原理的代码落地，do_fork/do_execve等函数实现了原语的核心逻辑。<br>差异：原理中的fork可能涉及写时复制（COW）优化，实验中是简单的内存空间拷贝；原理的exec支持磁盘文件加载，实验中是直接加载内核链接的二进制镜像。 |
| 用户进程地址空间管理（mm_struct、vma、页表） | 虚拟内存管理 | 含义：每个用户进程拥有独立虚拟地址空间，通过mm_struct管理虚拟内存区域（vma），页表实现虚拟地址到物理地址的映射；copy_range/exit_range等函数完成地址空间的拷贝与释放。<br>关系：实验是虚拟内存原理的进程级应用，体现了“进程地址空间隔离”的核心思想。<br>差异：原理中的虚拟内存包含缺页异常、交换区等机制，实验中仅实现了基础的地址空间创建、拷贝与释放。 |
| 第一个用户进程的创建（kernel_execve、load_icode） | 进程启动流程 | 含义：通过内核线程user_main调用kernel_execve，借助ebreak触发中断，在中断处理中完成用户程序加载（load_icode），并修改sstatus寄存器的SPP位实现从内核态首次进入用户态。<br>关系：实验解决了原理中“内核如何启动第一个用户进程”的鸡生蛋问题。<br>差异：原理中第一个用户进程（如init）由内核从磁盘加载，实验中是静态链接到内核镜像的简化方式。 |
| 僵尸进程与孤儿进程处理（do_exit中对子进程的托管） | 进程回收机制 | 含义：进程退出后进入僵尸态，需父进程wait回收资源；若父进程先退出，子进程会被initproc托管，避免成为孤儿进程。<br>关系：实验严格遵循原理的进程回收规则，保证资源不泄露。<br>差异：原理中的init进程是用户态进程，实验中的initproc是内核线程。 |
| GDB调试用户进程（加载用户程序符号表） | 调试器原理（符号表、断点） | 含义：用户程序静态链接到内核，需手动加载符号表才能调试用户态代码；断点设置在ecall/sret处可跟踪特权级切换流程。<br>关系：实验是调试器原理在嵌入式系统中的应用。<br>差异：原理中的调试支持动态加载的用户程序，实验中是静态链接的特殊场景。 |

## OS原理中重要但实验未覆盖的知识点
### 进程调度算法的多样性
实验中未体现多级反馈队列、优先级调度、实时调度等复杂调度算法，仅实现了基础的调度器框架（schedule函数），未深入调度策略的设计。而OS原理中调度算法是核心，直接影响系统的吞吐量、响应时间等指标。

###  进程间通信（IPC）机制
实验未涉及管道、消息队列、共享内存、信号量等IPC方式，而原理中IPC是多进程协作的关键，用于解决进程间的数据传输与同步互斥问题。

###  内存管理的高级机制
实验未实现写时复制（COW）、缺页异常处理、交换空间（Swap）、内存映射文件（mmap）等机制。而原理中这些机制是提升内存利用率、实现虚拟内存扩展性的核心。

### 设备管理与驱动
实验未涉及字符设备、块设备的驱动开发，也未实现设备文件、IO多路复用等机制，而原理中设备管理是OS与硬件交互的桥梁，负责抽象硬件接口并提供统一的IO服务。

## 调试：QEMU指令处理与TCG翻译分析

### ecall和sret指令的QEMU处理流程

#### ecall指令处理
当ucore内核或用户程序执行ecall指令时，QEMU通过以下流程处理：

1. **指令解码**：QEMU的RISC-V解码器识别ecall指令
2. **TCG翻译**：`translate.c`中的`gen_ecall`函数生成TCG IR（中间表示）
3. **调用辅助函数**：通过`gen_helper_exception`调用`cpu_helper.c`中的`helper_exception`函数
4. **异常处理**：
   - 保存当前PC到`sepc`寄存器
   - 设置异常原因到`scause`寄存器
   - 保存当前特权级到`prev_priv`
   - 切换到内核态（设置`priv`为`PRV_S`）
   - 跳转到异常处理程序（`stvec`指向的地址）

#### sret指令处理
当内核执行sret指令返回用户态时，QEMU处理流程：

1. **指令解码**：识别sret指令
2. **TCG翻译**：`translate.c`中的`gen_sret`函数生成TCG IR
3. **调用辅助函数**：通过`gen_helper_sret`调用`cpu_helper.c`中的`helper_sret`函数
4. **返回处理**：
   - 恢复用户程序PC（从`sepc`加载）
   - 切换回用户态（恢复`prev_priv`）
   - 设置中断状态（恢复`SIE`位）

### 涉及的QEMU源码关键流程

在调试过程中，主要涉及以下QEMU源码：

1. **`riscv/translate.c`**：负责指令解码和TCG IR生成
   - `gen_ecall`：ecall指令的TCG翻译函数
   - `gen_sret`：sret指令的TCG翻译函数
   - `translate_insn`：主指令翻译入口

2. **`riscv/cpu_helper.c`**：包含指令执行的辅助函数
   - `helper_exception`：处理异常的核心函数
   - `helper_sret`：处理sret指令的核心函数
   - `helper_interrupt`：处理中断的辅助函数

3. **`tcg/tcg.c`**：TCG引擎的核心实现
   - 负责TCG IR的优化和宿主机代码生成

### TCG翻译功能详解

TCG（Tiny Code Generator）是QEMU的动态二进制翻译引擎，核心功能包括：

1. **中间表示生成**：将目标架构（RISC-V）指令转换为TCG IR
2. **IR优化**：对生成的IR进行优化，提高执行效率
3. **代码生成**：将优化后的IR转换为宿主机（如x86-64）指令
4. **代码缓存**：缓存生成的宿主机指令，避免重复翻译

在执行ecall和sret指令时，TCG将这些特殊指令转换为对辅助函数的调用，实现了从用户态到内核态的切换和异常处理。

### 双重GDB调试实验的相关性

另一个双重GDB调试实验同样涉及TCG翻译功能和指令处理机制：

1. **指令翻译**：所有目标架构指令都需要通过TCG翻译为宿主机指令
2. **断点机制**：GDB的断点功能依赖于TCG在特定指令处插入陷阱
3. **寄存器访问**：通过TCG提供的接口访问和修改虚拟CPU寄存器
4. **异常处理**：类似ecall/sret的特殊指令处理机制

主要区别在于目标架构和具体指令集的不同，但核心原理和调试方法是相通的。

### 调试过细节

在调试过程中，我发现：

1. **指令翻译的延迟**：第一次执行某段代码时会有轻微的延迟（TCG翻译时间），后续执行会使用缓存的宿主机指令，速度显著提升

2. **寄存器的虚拟性**：QEMU模拟的寄存器与真实硬件寄存器的行为完全一致，但实际上是通过内存模拟实现的

3. **特权级切换**：在执行ecall指令时，特权级的切换是通过修改QEMU内部的状态变量实现的，而不是真正的硬件切换

### 软件模拟硬件的启示

通过观察QEMU模拟器的工作原理，深刻理解了：

1. **硬件行为的可模拟性**：复杂的硬件行为可以通过软件精确模拟
2. **抽象层的力量**：TCG作为中间层，使QEMU能够支持多种目标架构
3. **性能与准确性的平衡**：QEMU在保证模拟准确性的同时，通过TCG优化实现了较高的性能
4. **调试的便捷性**：软件模拟使得调试硬件行为变得更加容易，可以在指令级别观察和控制执行流程

这些知识对于理解计算机系统的工作原理和设计高性能模拟器具有重要意义。



