# 操作系统实验五报告

## 练习3：阅读分析源代码，理解进程执行 fork/exec/wait/exit 的实现，以及系统调用的实现

### fork/exec/wait/exit 执行流程分析

#### fork
##### 用户态操作
1. 用户程序调用 fork() 函数（封装在 user/libs/ulib.c）。
2. fork() 触发用户态系统调用封装函数 syscall(SYS_fork)，通过内联汇编设置系统调用号 a7=SYS_fork，执行 ecall 指令，触发特权级切换。
##### 内核态操作
1. ecall 触发异常，进入内核异常处理入口 __alltraps，保存用户态上下文到内核栈。
2. 内核根据系统调用号分发到 sys_fork 函数，调用 do_fork 核心逻辑
3. do_fork 完成：复制父进程 proc_struct、复制内存空间（copy_mm）、复制页表、设置子进程状态为 PROC_RUNNABLE，加入就绪队列。
4. 内核恢复上下文，通过 sret 指令返回用户态；父进程返回子进程 PID，子进程返回 0。
##### 交错执行与结果返回
交错：用户态 ecall → 内核态创建子进程 → sret 回到用户态，父子进程分别继续执行。
结果返回：内核在处理完成后，将返回值写入 a0 寄存器；sret 回到用户态后，用户态 syscall 函数读取 a0 寄存器值，作为 fork() 的返回值。

#### 1.2 exec
##### 用户态操作
1. 用户程序调用 exec() 系列函数（实验中通过 kernel_execve 触发），封装为系统调用 syscall(SYS_exec)。
2. 设置系统调用号、传递程序名/二进制数据等参数，执行 ecall 进入内核。
##### 内核态操作
1. 异常处理后分发到 sys_exec，调用 do_execve 核心逻辑。
2. do_execve 完成：回收当前进程旧的用户内存空间（exit_mmap）、调用 load_icode 加载新程序的 ELF 镜像到用户空间、设置新的程序入口地址。
3. 恢复上下文，sret 返回用户态，新程序从入口地址开始执行。
##### 交错执行与结果返回
交错：用户态发起调用 → 内核态替换进程镜像 → 返回用户态执行新程序。
结果返回：若加载成功，无返回值（新程序直接执行）；若失败，内核设置错误码到 a0，返回用户态后提示执行失败。

#### 1.3 exit
##### 用户态操作
1. 用户程序调用 exit(int error_code) 函数（user/libs/ulib.c）。
2. 触发系统调用 syscall(SYS_exit, error_code)，执行 ecall 进入内核。
##### 内核态操作
1. 异常处理后分发到 sys_exit，调用 do_exit 核心逻辑。
2. do_exit 完成：回收用户内存空间（exit_mmap）、设置进程状态为 PROC_ZOMBIE、保存退出码、唤醒父进程、将子进程托管给 initproc、调用 schedule() 切换到其他进程。
3. 僵尸进程的资源（内核栈、proc_struct）需等待父进程 wait 时回收。
##### 交错执行与结果返回
交错：用户态发起退出 → 内核态回收大部分资源并切换进程 → 进程不再返回用户态。
结果返回：无返回值给当前进程，退出码保存在 proc_struct 中，供父进程 wait 读取。

#### 1.4 wait
##### 用户态操作
1. 用户程序调用 wait()/waitpid() 函数（user/libs/ulib.c）。
2. 触发系统调用 syscall(SYS_wait, pid, &store)，执行 ecall 进入内核。
##### 内核态操作
1. 异常处理后分发到 sys_wait，调用 do_wait 核心逻辑。
2. do_wait 完成：遍历子进程，若存在僵尸子进程，则读取其退出码、回收僵尸进程的内核栈和 proc_struct；若无子进程或子进程未退出，则设置父进程状态为 PROC_WAITING，调用 schedule() 切换进程。
3. 子进程退出后唤醒父进程，父进程恢复执行，通过 sret 返回用户态。
##### 交错执行与结果返回
交错：用户态发起等待 → 内核态检查子进程状态，若需等待则切换进程 → 子进程退出后唤醒父进程 → 返回用户态。
结果返回：内核将子进程 PID 和退出码写入 a0 和用户态传入的 store 指针指向的地址，用户态函数读取后返回。

### ucore用户态进程执行状态生命周期图
┌─────────────────┐     进程创建（kernel_execve/load_icode）     ┌─────────────────┐
│                 │ ──────────────────────────────────────────> │ PROC_RUNNABLE   │
│     [初始态]    │                                             │ （就绪态）      │
└─────────────────┘                                             └─────────┬───────┘
                                                                           │
                                                                           │ 调度器选中（schedule()）
                                                                           ▼
┌─────────────────┐     父进程wait回收资源（do_wait()）          ┌─────────────────┐
│  资源释放，进程  │ <───────────────────────────────────────── │ PROC_ZOMBIE     │
│      消亡       │                                             │ （僵尸态）      │
└─────────────────┘                                             └─────────┬───────┘
                                                                           │
                                                                           │ 进程调用exit()（sys_exit/do_exit）
                                                                           ▼
┌─────────────────┐     被唤醒/等待超时（wakeup_proc()）         ┌─────────────────┐
│ PROC_RUNNABLE   │ <───────────────────────────────────────── │ PROC_WAITING    │
│ （就绪态）      │                                             │ （等待态）      │
└─────────┬───────┘                                             └─────────┬───────┘
          │                                                             │
          │ 调度器选中（schedule()）                                    │
          ▼                                                             │
┌─────────────────────────────────────────────────────────────────┐      │
│ PROC_RUNNING（运行态）                                          │      │
├─────────────────────────────────────────────────────────────────┤      │
│ 触发事件/函数                状态转换结果                         │      │
│ ────────────────             ────────────────                    │      │
│ 1. 调用fork()（sys_fork/do_fork）                                │      │
│    → 子进程进入PROC_RUNNABLE，父进程保持PROC_RUNNING             │      │
│                                                                 │      │
│ 2. 调用exec()（sys_exec/do_execve）                              │      │
│    → 替换程序镜像，仍保持PROC_RUNNING                            │      │
│                                                                 │      │
│ 3. 调用wait()（sys_wait/do_wait）且无僵尸子进程                  │      │
│    → 进入PROC_WAITING                                           │ ─────> │
│                                                                 │
│ 4. 调用yield()（sys_yield/do_yield）                            │
│    → 主动放弃CPU，回到PROC_RUNNABLE                             │
│                                                                 │
│ 5. 时间片耗尽/中断（timer_interrupt）                            │
│    → 回到PROC_RUNNABLE                                          │
│                                                                 │
│ 6. 调用exit()（sys_exit/do_exit）                                │
│    → 进入PROC_ZOMBIE                                            │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘
#### 状态变换说明
1. PROC_RUNNABLE（就绪态）：进程已创建/被唤醒，等待调度器选中；由 do_fork/wakeup_proc 触发进入此态。
2. PROC_RUNNING（运行态）：调度器选中进程，占用 CPU 执行；由 schedule 函数触发状态切换。
3. PROC_WAITING（等待态）：进程调用 wait 且无子进程退出，或等待其他事件；由 do_wait 触发，被唤醒后回到就绪态。
4. PROC_ZOMBIE（僵尸态）：进程调用 exit，用户资源已回收，等待父进程回收内核资源；由 do_exit 触发，父进程 wait 后资源释放，进程消亡。

### make grade 验证
#### 执行 make grade 后，若所有应用程序检测项输出 ok，说明 fork/exec/wait/exit 的实现逻辑正确，用户进程的创建、切换、退出和资源回收流程无问题。


## 实验重要知识点与对应OS原理知识点的理解
| 实验知识点 | 对应OS原理知识点 | 含义、关系与差异 |
|------------|------------------|------------------|
| 用户态与内核态的特权级切换（ecall/sret） | 特权级划分与模式切换 | 含义：RISC-V的U态（用户态）权限受限，无法执行特权指令；S态（内核态）拥有完整硬件访问权限。ecall触发异常从U态切到S态，sret完成中断处理后从S态切回U态。<br>关系：实验是原理的硬件级实现，ecall/sret是特权级切换的具体指令载体。<br>差异：原理侧重“为什么要划分（隔离保护、资源管控）”，实验侧重“怎么切换（指令触发、中断上下文保存）”。 |
| 系统调用框架（syscall.c、trap处理） | 系统调用机制 | 含义：用户程序通过标准化接口请求内核服务，核心流程是用户态封装调用→ecall触发异常→内核态中断处理→执行系统调用函数→sret返回。<br>关系：实验完整复现了原理的核心流程，包括系统调用号定义、参数传递、中断门注册。<br>差异：原理是通用模型（如Unix的syscall流程），实验针对ucore的精简实现，用ebreak模拟内核态发起exec调用的特殊场景。 |
| 进程管理系统调用（sys_fork/sys_exec/sys_exit/sys_wait） | 进程控制原语 | 含义：<br>- fork：复制父进程地址空间生成子进程，父子进程从fork返回处继续执行；<br>- exec：替换当前进程的内存空间和执行代码，保持PID不变；<br>- exit：进程主动终止，释放大部分资源并进入僵尸态；<br>- wait：父进程等待子进程退出，回收僵尸进程的剩余资源（内核栈、PCB）。<br>关系：实验是原理的代码落地，do_fork/do_execve等函数实现了原语的核心逻辑。<br>差异：原理中的fork可能涉及写时复制（COW）优化，实验中是简单的内存空间拷贝；原理的exec支持磁盘文件加载，实验中是直接加载内核链接的二进制镜像。 |
| 用户进程地址空间管理（mm_struct、vma、页表） | 虚拟内存管理 | 含义：每个用户进程拥有独立虚拟地址空间，通过mm_struct管理虚拟内存区域（vma），页表实现虚拟地址到物理地址的映射；copy_range/exit_range等函数完成地址空间的拷贝与释放。<br>关系：实验是虚拟内存原理的进程级应用，体现了“进程地址空间隔离”的核心思想。<br>差异：原理中的虚拟内存包含缺页异常、交换区等机制，实验中仅实现了基础的地址空间创建、拷贝与释放。 |
| 第一个用户进程的创建（kernel_execve、load_icode） | 进程启动流程 | 含义：通过内核线程user_main调用kernel_execve，借助ebreak触发中断，在中断处理中完成用户程序加载（load_icode），并修改sstatus寄存器的SPP位实现从内核态首次进入用户态。<br>关系：实验解决了原理中“内核如何启动第一个用户进程”的鸡生蛋问题。<br>差异：原理中第一个用户进程（如init）由内核从磁盘加载，实验中是静态链接到内核镜像的简化方式。 |
| 僵尸进程与孤儿进程处理（do_exit中对子进程的托管） | 进程回收机制 | 含义：进程退出后进入僵尸态，需父进程wait回收资源；若父进程先退出，子进程会被initproc托管，避免成为孤儿进程。<br>关系：实验严格遵循原理的进程回收规则，保证资源不泄露。<br>差异：原理中的init进程是用户态进程，实验中的initproc是内核线程。 |
| GDB调试用户进程（加载用户程序符号表） | 调试器原理（符号表、断点） | 含义：用户程序静态链接到内核，需手动加载符号表才能调试用户态代码；断点设置在ecall/sret处可跟踪特权级切换流程。<br>关系：实验是调试器原理在嵌入式系统中的应用。<br>差异：原理中的调试支持动态加载的用户程序，实验中是静态链接的特殊场景。 |


## OS原理中重要但实验未覆盖的知识点
### 进程调度算法的多样性
实验中未体现多级反馈队列、优先级调度、实时调度等复杂调度算法，仅实现了基础的调度器框架（schedule函数），未深入调度策略的设计。而OS原理中调度算法是核心，直接影响系统的吞吐量、响应时间等指标。

###  进程间通信（IPC）机制
实验未涉及管道、消息队列、共享内存、信号量等IPC方式，而原理中IPC是多进程协作的关键，用于解决进程间的数据传输与同步互斥问题。

###  内存管理的高级机制
实验未实现写时复制（COW）、缺页异常处理、交换空间（Swap）、内存映射文件（mmap）等机制。而原理中这些机制是提升内存利用率、实现虚拟内存扩展性的核心。

### 设备管理与驱动
实验未涉及字符设备、块设备的驱动开发，也未实现设备文件、IO多路复用等机制，而原理中设备管理是OS与硬件交互的桥梁，负责抽象硬件接口并提供统一的IO服务。